{"/fides/overview":{"title":"Overview","data":{"":"By default, key will be passed to fetcher as the argument. So the following 3 expressions are equivalent:\nuseSWR('/api/user', () => fetcher('/api/user'))\nuseSWR('/api/user', url => fetcher(url))\nuseSWR('/api/user', fetcher)","multiple-arguments#Multiple Arguments":"In some scenarios, it's useful to pass multiple arguments (can be any value or object) to the fetcher function.\nFor example an authorized fetch request:\nuseSWR('/api/user', url => fetchWithToken(url, token))\nThis is incorrect. Because the identifier (also the cache key) of the data is '/api/user',\neven if token changes, SWR will still use the same key and return the wrong data.Instead, you can use an array as the key parameter, which contains multiple arguments of fetcher:\nconst { data: user } = useSWR(['/api/user', token], fetchWithToken)\nThe function fetchWithToken still accepts the same 2 arguments, but the cache key will also be associated with token now.","passing-objects#Passing Objects":"Since SWR 1.1.0, object-like keys will be serialized under the hood automatically.\nSay you have another function that fetches data with a user scope: fetchWithUser(api, user). You can do the following:\nconst { data: user } = useSWR(['/api/user', token], fetchWithToken)\n\n// ...and then pass it as an argument to another useSWR hook\nconst { data: orders } = useSWR(user ? ['/api/orders', user] : null, fetchWithUser)\nYou can directly pass an object as the key, and fetcher will receive that object too:\nconst { data: orders } = useSWR({ url: '/api/orders', args: user }, fetcher)\n\nIn older versions (< 1.1.0), SWR shallowly compares the arguments on every render, and triggers revalidation if any of them has changed."}},"/enterprise/test":{"title":"Test","data":{"":"Upgrade to the latest version (â‰¥ 1.0.0) to use this feature.\n\nIn most cases, you shouldn't directly write to the cache, which might cause undefined behaviors of SWR. If you need to manually mutate a key, please consider using the SWR APIs.\nSee also: Mutation, Reset Cache Between Test Cases.\nBy default, SWR uses a global cache to store and share data across all components. But you can also customize this behavior with the provider option of SWRConfig.Cache providers are intended to enable SWR with more customized storages.","cache-provider#Cache Provider":"A cache provider is Map-like object which matches the following TypeScript definition (which can be imported from swr):\ninterface Cache<Data> {\nget(key: string): Data | undefined\nset(key: string, value: Data): void\ndelete(key: string): void\n}"}},"/ethyca/overview":{"title":"Overview","data":{"":"By default, key will be passed to fetcher as the argument. So the following 3 expressions are equivalent:\nuseSWR('/api/user', () => fetcher('/api/user'))\nuseSWR('/api/user', url => fetcher(url))\nuseSWR('/api/user', fetcher)","multiple-arguments#Multiple Arguments":"In some scenarios, it's useful to pass multiple arguments (can be any value or object) to the fetcher function.\nFor example an authorized fetch request:\nuseSWR('/api/user', url => fetchWithToken(url, token))\nThis is incorrect. Because the identifier (also the cache key) of the data is '/api/user',\neven if token changes, SWR will still use the same key and return the wrong data.Instead, you can use an array as the key parameter, which contains multiple arguments of fetcher:\nconst { data: user } = useSWR(['/api/user', token], fetchWithToken)\nThe function fetchWithToken still accepts the same 2 arguments, but the cache key will also be associated with token now.","passing-objects#Passing Objects":"Since SWR 1.1.0, object-like keys will be serialized under the hood automatically.\nSay you have another function that fetches data with a user scope: fetchWithUser(api, user). You can do the following:\nconst { data: user } = useSWR(['/api/user', token], fetchWithToken)\n\n// ...and then pass it as an argument to another useSWR hook\nconst { data: orders } = useSWR(user ? ['/api/orders', user] : null, fetchWithUser)\nYou can directly pass an object as the key, and fetcher will receive that object too:\nconst { data: orders } = useSWR({ url: '/api/orders', args: user }, fetcher)\n\nIn older versions (< 1.1.0), SWR shallowly compares the arguments on every render, and triggers revalidation if any of them has changed."}}}